<!DOCTYPE html>
<html>
<head>
  <title>Reservoir Concentration Ratio</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <div id="plot" style="width:100%;height:500px;"></div>

  <script>
    // Parameters
    const v_SFR = 5, v_SMR = 5, v_SFD = 5, v_SMD = 0;
    const dQ = 1, Qm = 14, Qf = 6, W = 30, V0 = 500;
    const C0 = 1;
    const D0 = 1;
    const tend = 300;

    // Experimental time and concentration data
    const T_SFR = [0, 60, 120, 180, 240, 300];
    const T_SMR = [0, 60, 120, 180, 240, 300];
    const c_FR = [0, 0.2, 0.3, 0.3, 0.3, 0.4];
    const c_MR = [1, 0.7, 0.5, 0.4, 0.4, 0.4];

    // Define simulation parameters
    const Vm = W * 0.34;
    const Vf = W * 0.074;
    const tspan = [...new Set([...Array(tend/5 + 1).keys()].map(i => i * 5).concat(T_SMR))].sort((a, b) => a - b);

    // Initial condition [cm, cf, cM, cF]
    const y0 = [0, 0, C0, 0];

    // Runge-Kutta 4th order ODE solver
    function rk4(f, y0, tspan) {
      const dt = 1;
      let y = y0.slice();
      let Y = [y.slice()];
      let T = [tspan[0]];

      for (let i = 1; i < tspan.length; i++) {
        const t = tspan[i - 1];
        const tNext = tspan[i];
        while (T[T.length - 1] < tNext) {
          const h = Math.min(dt, tNext - T[T.length - 1]);
          const k1 = f(T[T.length - 1], y);
          const k2 = f(T[T.length - 1] + h/2, y.map((yi, j) => yi + h/2 * k1[j]));
          const k3 = f(T[T.length - 1] + h/2, y.map((yi, j) => yi + h/2 * k2[j]));
          const k4 = f(T[T.length - 1] + h, y.map((yi, j) => yi + h * k3[j]));
          y = y.map((yi, j) => yi + h/6 * (k1[j] + 2*k2[j] + 2*k3[j] + k4[j]));
          Y.push(y.slice());
          T.push(T[T.length - 1] + h);
        }
      }

      return { t: T, y: Y };
    }

    function sampleVolume(t, timesR, timesD, vD, vR) {
      const nD = timesD.filter(td => td <= t).length;
      const nR = timesR.filter(tr => tr <= t).length;
      return vD * nD + vR * nR;
    }

    function Volume_RM(t) {
      return -t * dQ + V0 - sampleVolume(t, T_SMR, [], 0, v_SMR);
    }

    function Volume_RF(t) {
      return t * dQ + V0 - sampleVolume(t, T_SFR, [], 0, v_SFR);
    }

    // ODE system
    function odefcn(t, y) {
      const [cm, cf, cM, cF] = y;
      const Qrm = Qm + dQ;
      const Qrf = Qf - dQ;
      const VRM = Volume_RM(t);
      const VRF = Volume_RF(t);
      const Dt = D0;

      return [
        (Qm * cM - Qrm * cm - Dt * (cm - cf) + dQ * cf) / Vm,
        (Qf * (cF - cf) + Dt * (cm - cf)) / Vf,
        Qrm * (cm - cM) / VRM,
        Qrf * (cf - cF) / VRF
      ];
    }

    // Solve ODEs
    const result = rk4(odefcn, y0, tspan);
    const t = result.t;
    const cm = result.y.map(row => row[0]);
    const cf = result.y.map(row => row[1]);
    const cM = result.y.map(row => row[2]);
    const cF = result.y.map(row => row[3]);
    const cF_cM = cF.map((cfv, i) => cfv / cM[i]);

    // Experimental ratios
    const timeIntersect = T_SFR.filter(value => T_SMR.includes(value));
    const cF_plot = timeIntersect.map(t => c_FR[T_SFR.indexOf(t)]);
    const cM_plot = timeIntersect.map(t => c_MR[T_SMR.indexOf(t)]);
    const cF_div_cM_exp = cF_plot.map((v, i) => v / cM_plot[i]);

    // Plotting
    Plotly.newPlot('plot', [
      {
        x: t,
        y: cF_cM,
        mode: 'lines',
        name: 'Model prediction'
      },
      {
        x: timeIntersect,
        y: cF_div_cM_exp,
        mode: 'markers',
        name: 'Experimental points'
      }
    ], {
      title: 'Reservoir concentration ratio',
      xaxis: { title: 'time, min', range: [0, tend] },
      yaxis: { title: 'cF / cM', range: [0, Math.ceil(Math.max(...cF_cM.concat(cF_div_cM_exp)) * 10) / 10] }
    });
  </script>
</body>
</html>
